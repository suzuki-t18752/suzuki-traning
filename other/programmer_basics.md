# プログラマーの基礎的なこといろいろ

## 変数の再代入はしない！！！！！！！
- 参照透過性を損なう為
- 変数の中身が常に一定であればその変化を考慮する必要はない
 - その変化をテストする必要もない
 - その変化を見落とすリスクもない
### 参照透過性
- 関数は同じ引数に対して常に同じ値を返す
- 値は最初に定義した値から常に変わらない
 - f(X) = 2 になったらf(X)を何回呼び出しても2になること
###  関数型言語とは
- プログラムは関数定義の集合であり、関数呼び出しによってそれらを組み合わせる。
- 関数は first class object である。
 - first class objectはプログラミング言語において、たとえば生成、代入、演算、受け渡しといったその言語における基本的な操作を制限なしに使用できる対象
- 文という単位は無く、プログラムの実行とは式を評価することである。
- 参照透過性がある。
#### プログラムは関数定義の集合
- [参考](<<https://www.slideshare.net/parrotstudio/gunmaweb13-functionallanguageretry>>)

## 変更に強い修正をおこなおう
- 何かが追加、削除された場合でもバグになりにくいように修正しておくと良い
- 例えば？

## コードブロックをわけよう
- 意味ごとに分ける
  - データの取得、データの計算、返す結果など




## [プログラマが知るべき97のこと](https://xn--97-273ae6a4irb6e2hsoiozc2g4b8082p.com/)
- 技術的負債について
  - 正しくやることと素早くやることで天秤にかけるタイミングがある
    - その際にどうしても素早くやることを選ばなくてはならないことがある
    - その負債を放置しておくと後々リファクタリングが大変になったり、思わぬエラーを生むことになる
    - ので常にその負債のことを覚えて、タスクにいれておき、次回イテレーションで修正出来ないか検討するべき

- 関数型プログラミングを学ぶことの重要性
  - 関数型プログラミングを学ぶことで書くコードの品質が高まり、参照透過性も向上する
    - 可変な変数を使うような設定を行わないことが大切

- ユーザが何をするかを観察する
  - プログラマーの自分のようにシステムを使うクライアントは考えてシステムを使っていないし、視野も狭まっている
  - 自分の考えのままに設計するのではなく、クライアントの考えに沿って設計をしていくべき
  - その為にユーザーがどのように作業を行うのかを観察することも重要
  - だいたいのユーザーは同じところで失敗する、その部分に対応することで良いシステムになる

- コーディング規約を自動化する
  - プロジェクトごとにコーディングの方針等も決めるが全ての人がそれを守る、守れるものではない
  - シンプルに漏れる人やそもそも守る気がない人、時間に追われ守れない人もいる
  - レビューする人がそれを全て見切れる訳でもない
  - 自動化しておき、読みやすい、整備のしやすいコードを誰でも書けるようにしておくのがベスト
  - そして自動化したら定期的に規約を整備することも怠らない
  - rubyだとこんなのもある https://qiita.com/ybiquitous/items/7043d868e14311b28d65

- 美はシンプルさに宿る
  - コードを書く時に大切にすること
    - 可読性
    - 保守性
    - 開発効率
    - (言葉で表現するのが難しい)美しさ
  - コードの美しさはシンプルであること
    - メソッドも全て機能が絞りこまれており、名前を見ればすぐに、持っている機能がわかるようになっている

- リファクタリングの際に注意すべきこと
  - 最初にやること既存のコードベースと、そのコードに対して書かれたテストコードの洗い直し
    - 現状での良い点、悪い点、強み、弱みを1つずつ確認
    - 良い点、強みを残しながら、悪い点、弱みを克服する
    - 既存のコード、テストを十分に検証し過去の失敗に学ぶこと
  - 既存のコードを全て変更するべきではない
    - 既存のコードでしか出来ないこと、発見出来ないバグもあるかもしれない
    - あくまで既存のコードをいかして変更を行うべき
  - 変更は小さく、少しずつ
    - 一度に変更して大量のテストに失敗するよりも1つずつ通していこう
  - 個人の好みやエゴを入れない
    - 壊れてもいないものを治すのは無意味
    - コードの書き方の流儀や構造が自分の好みに合わない、自分のほうが前任者よりも能力があるのだから良いコードが書けるはずは不要
  - 新技術を使いたい、時代遅れという理由でリファクタリングをするべきではない
    - 新しい言語やフレームワークを使えば、今と同じことがもっとうまくやれるだろうはNG
    - コストの分析を行い、新しい言語やフレームワークの導入により、機能、保守性、生産性が著しく向上するという結論が得られた場合のみ行う

- コンテキストの確認を
  - プログラミングでは同じ処理がある場合に共通化、抽象化を行うが、今は同じ処理が掛かれていてもかつては違う処理で後々変更を行う際に苦労する可能性がある
  - その処理が作られた経緯、どのように使われるべきものなのかをきちんと確認するべき

- モージュールの改変時は触る前よりもきれいする
  - モジュールに新たなコードを加える場合には、そのコードを「美しく」する
  - 既存のコードを触る場合には、チェックイン前にどこか1箇所でいいのでする
    - 変数名をより適切なものに変えたり、大きい関数を2つの小さくよりシンプルな関数に分割するなどなど

- 他人よりまず自分を疑う
  - バグが発生した場合にツールやモジュールのせいだと思い込むふしがプログラマーにはある
  - しかし大抵は自分の書いたコードに問題がある為、自分のコードの調査をするべき
  - デバッグに関して一般にすべきと言われていることをやる
  - 問題箇所を切り分け、呼び出し先をスタブに置き換え、テストを書いてみる
  - 呼び出しの作法、共有ライブラリ、バージョン番号のチェックも忘れずに
  - マシンやビルド設定を変えて、例えばデバッグ用、リリース用両方の環境で実行する
  - 問題発見の報告を受けたが、それを自分で再現できない場合には、報告者が実際にどういうことをしているのか、その現場を見るべき

- ツールの選択は慎重に
  - アプリケーションを0から作成するよりもライブラリやフレームワーク等のツールを使った方がコスト面や工数で恩恵を受けられることが多い
  - ツールの品質が高まっていることからバグなども起こりにくくなっている
  - ただ、複数のツールを組み合わせることで管理が難しくなったり、バージョンアップして今までのように組み合わせることが出来なくなったり、難しい面もある
  - あるベンダーのツールのみに頼ったりするのも、柔軟性にかけ、コスト面でも不利になる場合がある
  - ツールは出来るだけ最低限に止め、インフラ等の低水準プログラミングの手間が省けることを重視すると良い

- コードレビュー
  - 間違いの訂正だけでなく、知識やコーディングルール等の共有、統一を図る為にも行われるべき
  - 誰か1人ではなく、何人かに見てもらうのが理想
  - 定期的にレビューについてミーティングを行い、コーディングルールについては自動化されているとさらに良い

- コメント
  - コメントはコードを書いた意図、何の為にそのコードが書かれたのか、そのコードで何がしたいのか分かるようにする
  - 読む人にとって価値のあるコメントを、コードを読めば分かることをコメントするのはノイズでしかない
  - そういうことをコメントしている場合はメソッド名や変数名を見直すべき

- コードの書き方
  - メソッドを作ろうとして別のクラスに同じようなメソッドがあるからそれを使うというのは悪いことではない
  - しかしそのメソッドの利用目的は本当に同じなのか考える必要がある
  - そもそも同じメソッドを書きたくない、同じメソッドはノイズになるという書き手側のエゴの可能性もある
  - 似たようなメソッドだが名前を変えた方が使う側、読む側にとっては分かりやすい場合も多い

- デプロイやインストールは早めにやっておく
  - ユーザーが使うのはデプロイ済み、インストール済みの環境
  - ユーザーの使う環境で開発テストを行うことが大切
  - 開発やテスト環境に依存していると実際の環境との際に気づくのが遅く修正を行うのも難しくなる

- 技術的例外とビジネス的例外をはっきりと区別する
  - 技術的例外
    - コーディングミス等
    - メソッドを呼び出すのに引数が足りなかったり、配列に17個しか値がないのに18個目を呼び出そうとするロジックがある等
  - ビジネス的例外
    - ユーザーが本来の使い方とは違う使い方をしている等
    - 銀行口座からお金を引き出そうとして預金額よりも多い金額を指定する等
  - この2つの例外は明確に分けて処理を行うべき
    - 具体的には
      - 技術的例外はStandardError等で処理されるので下手にキャッチせず、トップレベルのメカニズムに任せるようにするべき
      - ビジネス的例外は予め予想をしておき、専用の例外を作成してキャッチするようなロジックを作る等

- 何かを身に着ける
  - 何かを身に着けその道のエキスパートになるには最低1万時間は必要
  - その訓練は身に着けたいその何かをいくつかに分割して、それを1つずつ反復していくことが大切
  - 自分の能力を超えること、苦手なことに挑戦することも大事

- 変更を恐れない
  - どこかを変更すると関連のないところでエラーが発生するようなシステムに関わることがある
  - その場合多くの人は既存の部分に触れないようにモジュール等を作って対応しようとする
  - しかし関係のないところでエラーが発生することを恐れず変更をするべき
  - 外科医が体を切って病気を直すように一時的な痛みはあるが、後々直すことが出来る
  - そのようにプログラマーもリファクタリングを行い、見やすい、神経質にならずに変更が行えるシステムにするべき

- 複数の言語を学ぶ
  - 複数の言語を学ぶ際は言語の特徴や文化を抑えることも大切
  - 言語ごとの比較をすることでより綺麗なコードが書けるようになる

- 関わる人が何をしているのか知ることが大切
  - 関係ないように思えて実はその人のしていることで自分の仕事が楽になっている可能性もある
  - 全てを知る必要はないかもしれないが、少しだけでも触れておくといろいろスムーズに進むこともある

## 手を動かしてわかるクリーンアーキテクチャ　ヘキサゴナルアーキテクチャによるクリーンなアプリケーション開発
webアダプタ→コントローラークラス
永続化アダプタ→リポジトリクラス
ドメイン→モデルクラス
サービス→サービスクラス(実際のユースケースのロジックをまとめたもの)

### クリーンアーキテクチャ（ヘキサゴナルアーキテクチャ）
保守容易性を向上させよう
保守容易性を向上させることはシステムの変更を行うのに時間がかからなくなるので開発者の生産性を向上させる、生産性が向上することで成果がよりでるので開発者の満足度が向上し離職率も低下する。
さらに変更を行う際に複数の選択肢がある場合、保守容易性に重きを置くことでどのような変更を行うのか決めやすくなる。

### 従来のアーキテクチャの問題（多層orレイヤードアーキテクチャ）
多層アーキテクチャは簡潔にweb層（httpリクエストを受け取る）→ドメイン層（リクエストを処理する、ビジネスロジック）→永続化層（データの取得や更新）に別れ、上の層は下の層に依存している。
本来、開発対象のビジネス領域（ドメイン）に課せられているルールや方針をモデリングし、そのアプリケーションのユーザーがそのルールや方針に沿って仕事を効率よく行なえるようにすることが目的だが、多層アーキテクチャでは下層に依存をする為、ビジネスロジック（振る舞い）ではなく、データベース（状態）を中心に開発をしてしまっている（O/Rマッパーの影響もある）。
ドメイン層のサービスに課せられる責務を限定し、各サービスが1つのユースケースしか扱わないような設計にした場合、ユースケースが見つけやすくなる。たとえば、ユーザーを登録（register）するユースケースを探す場合、RegisterUserServiceと名付けたサービスを作っておけば、対象のユースケースを見つけ出すことが容易になり、もしユーザーに関するユースケースをすべて扱うようにしたUserServiceという名前のサービスを作ってしまうと、対象のユースケースを見つけ出すために、わざわざUserServiceクラスのコードを見て、該当するコードを見つけ出す手間をかけることになる。

### 依存関係の逆転
単一責任の法則
コンポーネントは1つのことを行うべき、ではなく、コンポーネントを変更する理由は1つだけになるようにするべき、というのが本当の法則
各層でそのドメインを表すエンティティを待つべき
そうすることでドメイン層の実装はビジネスロジックだけを見ればよくなり、ドメイン層だけをみてモデルを表現できる
各層とのやりとりをアダプタ（インターフェースクラス）で行う
（Rubyは型がないのでダックタイピングを用いることで表現する）

### 入力値の確認かビジネスルールの確認かを見分ける
ドメインモデルの現在の状態を確認する必要があるかどうか。
銀行口座の送金を例に、送金元の口座残高を超えた送金はしてはならない、は現在の残高確認が必要なのでビジネスルールに関する確認。
送金額は0より大きくなくてはならない、は口座の残高を確認する必要がないので、入力値の確認。
・ドメインの値を変更するメソッドと値を取得するメソッドは分離すべき
コマンドクエリ分離の原則（コマンド: 値を変更する処理、クエリ: 値を取得する処理）と単一責任者の原則に基づく

### テストを書く
前提→実効→結果の確認の順になる
前提: テストを行うメソッドを実効するのに必要なモジュールの読み込み、データの登録、引数やテストを行うクラスのインスタンス化などの準備などを行う
実効: テストを行うメソッドを実効し、返り値を受け取る
結果の確認: 返り値が想定していた値か確認、データベースの更新が行われる場合はデータの変化を確認、特定のクラスやメソッドが呼び出されているのか確認

### 既に短絡的な考えの実装が行われてるプロダクトでは追加で実装されるものも短絡的な考えで行われやすいので注意


## 設計の本？
DBの設計: 制約をきちんと入れること、一意性制約、notnull制約、外部キー
オブジェクトとテーブルの設計は異なる、独立させるべき
画面の設計: タスクベースの画面、情報を一括ではなく一つ一つ登録出来るようにする、スマホが増えたから
APIでpostとputの違い: postはデータを登録しそのデータの一意な値を貰う(実質新規登録)、putはデータの一意な値を使ってその一意な値に一致するデータの登録を行う(実質更新だが任意で一意の値を指定するだけで新規登録はできる)
登録と参照は別のAPIで行うべき: POSTで登録が完了した後、登録したものを識別できる一意の値のみを返し、詳細はその一意の値を使ってGETさせるようにする

ジェネリックス: 同じコードで違うデータ型を処理できるようにする仕組みもしくはメソッドの共通化をする際に用いる、違うクラスでも同じメソッドを呼び出しクラスごとの結果を取得出来るようにする
プロセス: 実行中のプログラム、メモリ上で動く、プロセス同士は情報共有できない
スレッド: プロセスの中の実行単位、スレッド同士は情報共有ができて上位プロセスの情報も勿論使える


## Good code Bad code
モジュールに集約して使いまわせるようにする
テストを書く、テストを考慮したコーティングをする、小さなメソッドに分けるなど
抽象化レイヤーを考えるならAPIを意識するとよい、外から見るとシンプルだが中身は詳細になっているから
1つの関数で多くのことをやりすぎない、if文でネストが深くなり読みづらい
ロジック1つを1つの分かりやすい関数名をつけて分けると読みやすい
コードを読みやすくする、モジュール化する、再利用しやすくする、テストをしやすくする
コードを書く際に、自分にとって明確でも他人には明確でない、他人は不注意でコードを壊す、そして自分も自分の書いたコードを忘れるということを意識する
事前条件: システムの状態やコードに提供されるべき入力がコードを呼び出す前に正しくあるべきこと
事後条件: システムの新しい状態や返させるべき値などコードを呼び出した後に正しくあるべきこと
不変条件: コードの呼び出し前後で比較した際に変わるべきでないもの
