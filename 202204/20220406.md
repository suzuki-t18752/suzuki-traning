### aws DBの削除
1. 削除対象のデータベースを選択
- 親子がある場合、子のデータベースを選択する
  - 子が全て削除されると自動で親も削除される

2. アクション内の停止を選択する

3. リロードボタンを押下して停止中になっていることを確認

4. 少し待ち、停止中だったDBが停止済になっていることを確認

5. アクション内の削除を押下する

6. 画面上からDBがなくなる



### [mysql GROUP_CONCAT](https://dev.mysql.com/doc/refman/8.0/ja/aggregate-functions.html#function_group-concat)
- GROUP BYした際に使う
- 複数ある列を1つのカラムにまとめることが出来る
```
mysql> SELECT t_id, GROUP_CONCAT(p_id) FROM t_p GROUP BY t_id limit 10;
+-------------+----------------------------------------------------------------------------------------+
| t_id        | GROUP_CONCAT(p_id)                                                                     |
+-------------+----------------------------------------------------------------------------------------+
|           1 | 8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36   |
|           2 | 7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36 |
|           3 | 7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36 |
|           4 | 7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36 |
|           5 | 7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36 |
|           6 | 7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36 |
|           7 | 7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36 |
|           8 | 7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36 |
|           9 | 7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36 |
|          10 | 7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36 |
+-------------+----------------------------------------------------------------------------------------+
10 rows in set (0.00 sec)
```


- 結果は、group_concat_max_len システム変数で指定された最大長まで切り捨てられます。その変数のデフォルト値は 1024 です。 さらに高い値にも設定できますが、戻り値の有効な最大長は、max_allowed_packet の値によって制約されます。 実行時に group_concat_max_len の値を変更するための構文は、次のとおりです。ここで、val は符号なし整数です。
- 戻り値は、引数が非バイナリとバイナリのどちらの文字列であるのかに応じて、非バイナリ文字列またはバイナリ文字列になります。 結果の型は、group_concat_max_len が 512 以下の場合 (この場合、結果の型は VARCHAR または VARBINARY です) を除いて、TEXT または BLOB です。
```
mysql> SHOW VARIABLES LIKE 'group_concat_max_len';
+----------------------+-------+
| Variable_name        | Value |
+----------------------+-------+
| group_concat_max_len | 1024  |
+----------------------+-------+
1 row in set (0.00 sec)
```


### ピア
- https://e-words.jp/w/%E3%83%94%E3%82%A2.html#:~:text=%E3%83%94%E3%82%A2%E3%81%A8%E3%81%AF%E3%80%81%E5%90%8C%E5%83%9A%E3%80%81%E5%90%8C%E8%BC%A9,%E3%81%AE%E3%81%93%E3%81%A8%E3%82%92%E3%83%94%E3%82%A2%E3%81%A8%E3%81%84%E3%81%86%E3%80%82
- https://wa3.i-3-i.info/word1306.html
- サーバーとクライアントのような役割分担や上下関係のない、対等な機器同士が相互に通信する接続形態


### トラフィック
- https://wa3.i-3-i.info/word1972.html
- ネットワークに流れる情報もしくは情報量のこと



## ruby 速度向上について
- https://zenn.dev/universato/articles/20201210-z-ruby
### HashはStringよりもSymbolの方が早い
```
hash = []
10000.times do; hash << {'test' => 1, 'test2' => 2, 'test3' => 3}; end
Benchmark.realtime do; hash.map{|t| p t['test']; p t['test2']; p t['test3']}; end
=> 0.5202363999560475
Benchmark.realtime do; hash.map(&:symbolize_keys).map {|t| p t[:test]; p t[:test2]; p t[:test3]}; end
=> 0.539968500030227

100000.times do; hash << {'test' => 1, 'test2' => 2, 'test3' => 3}; end
Benchmark.realtime do; hash.map{|t| p t['test']; p t['test2']; p t['test3']}; end
=> 5.148713000002317
=> 3.9413106000283733
=> 4.42517649999354
=> 4.173284500022419
=> 3.981059300014749
Benchmark.realtime do; hash.map(&:symbolize_keys).map {|t| p t[:test]; p t[:test2]; p t[:test3]}; end
=> 4.419451100053266
=> 4.417661200044677
=> 4.711293799919076
=> 4.091005999944173
=> 4.3286230999510735

100000.times do; hash << {test: 1, test2: 2, test3: 3}; end
Benchmark.realtime do; hash.map {|t| p t[:test]; p t[:test2]; p t[:test3]}; end
=> 5.0257558999583125
=> 4.2126769999740645
=> 3.8549622000427917
=> 4.151256800047122
=> 3.9991251999745145
```
- 文字列が長い方が効果が高い
```
100000.times do; hash << {'test123456789' => 1, 'testtest123456789' => 2, 'testtesttest123456789' => 3}; end
Benchmark.realtime do; hash.map{|t| p t['test123456789']; p t['testtest123456789']; p t['testtesttest123456789']}; end
=> 5.308806000044569
=> 4.065432600094937
=> 4.814307799912058
=> 4.498210899997503
Benchmark.realtime do; hash.map(&:symbolize_keys).map{|t| p t[:test123456789]; p t[:testtest123456789]; p t[:testtesttest123456789]}; end
=> 5.446384100010619
=> 3.935182800050825
=> 3.8973109000362456
=> 3.9013007000321522

100000.times do; hash << {test123456789: 1, testtest123456789: 2, testtesttest123456789: 3}; end
Benchmark.realtime do; hash.map{|t| p t[:test123456789]; p t[:testtest123456789]; p t[:testtesttest123456789]}; end
=> 4.644412699970417
=> 3.51008959999308
=> 3.764685000060126
=> 3.6622434000018984
```

### Stringの結合
- 基本的には << を使うのが一番早い
  - ただ破壊的変更にあたる為、rails等では制限がかかるので注意
- あとStringクラスの変数を結合する場合は式展開("#{}")を使う方がよい
  - 速度的には遅くなるが式展開を使うと自動的にto_sメソッドが実行され、nil等の場合でも対応できるよう
    - そもそも先にnilは除外するべきだが
```
[3] pry(main)> a = 'test'
=> "test"
[4] pry(main)> b = ''
=> ""
[5] pry(main)> Benchmark.realtime do

    b += a
[5] pry(main)> Benchmark.realtime do
[5] pry(main)*   100000.times do
[5] pry(main)*     b += a
[5] pry(main)*   end
[5] pry(main)* end
=> 15.999634900013916
[6] pry(main)> a = 'test'
=> "test"
[7] pry(main)> b = ''
=> ""
[8] pry(main)> Benchmark.realtime do
[8] pry(main)*   100000.times do   do
[8] pry(main)*     b = "#{b}#{a}"
[8] pry(main)*   end
[8] pry(main)* end
=> 13.800291599938646
[16] pry(main)> Benchmark.realtime do
[16] pry(main)*   100000.times do
[16] pry(main)*     b << a
[16] pry(main)*   end
[16] pry(main)* end
=> 0.011096699978224933
```


### デベロッパーツールのパフォーマンスタブで処理時間の計測を行う
1. パフォーマンスタブを開く
2. 左上の黒丸(レコーディングボタン)を押下する
3. 処理を画面を操作して行う
4. 処理が終了したらstopボタンを押下する
5. 確認したい処理の範囲を選択する(画面の遷移状態が表示されているので目的の画面状態を範囲選択する)
  - さらにnetwork欄を開くことでAPIの処理時間を分かる



### bash ブレース展開
- {}内で指定した文字列を使った全てのパターンの文字列を生成する
```
suzuki@DESKTOP-G7N3ULO:~$ echo test{a,b}
testa testb
suzuki@DESKTOP-G7N3ULO:~$ echo test{a,b}c
testac testbc
suzuki@DESKTOP-G7N3ULO:~$ echo test{1..10}c
test1c test2c test3c test4c test5c test6c test7c test8c test9c test10c
```

### ハードコーディング
- 本来いくつかの処理に分けるべき処理をまとめてしまうこと

### ruby presenceメソッド
- 対象のオブジェクトがnil, "", " "(半角スペース), , {}(空のハッシュ)の時はnilを返し、それ以外の値の場合はその値を返す
- || と一緒に使うと便利
```
[3] pry(main)> [1, 2].presence
=> [1, 2]
[4] pry(main)> [].presence
=> nil
[5] pry(main)> [].presence || 1
=> 1
[6] pry(main)> [1].presence || 1
=> [1]
[7] pry(main)> 1.presence
=> 1
[8] pry(main)> nil.presence
=> nil
```

### ruby include? exclde?メソッド
- include?
  - 配列に対象の値が含まれていればtrue
- exclude?
  - 配列に対象の値が含まれていなければtrue
```
[1] pry(main)> [1, 2, 3].include?(1)
=> true
[2] pry(main)> [1, 2, 3].include?(4)
=> false
[3] pry(main)> [1, 2, 3].exclude?(4)
=> true
[4] pry(main)> [1, 2, 3].exclude?(1)
=> false
```



オブジェクト指向的には
使い方を変えることで処理が分岐されるのではなく、同じ使い方でも処理が分岐されるようになっているのが理想
カプセル化とポリモーフィズムの組み合わせ

- カプセル化
  - https://webpia.jp/encapsulation/
  - 外部から中身が見えない
  - 中身を意識しなくても使える
  - 情報を直接操作することをできなくして情報が壊れてしまうことを防止する
  - オブジェクト自身に適切な情報操作を委ねる
- ポリモーフィズム(多様性)
  - https://webpia.jp/polymorphism/
  - 中に入るものによって同じ関数でも違う処理を行える
  - 例
    - 設定
      - 動物のクラスがあり、それぞれ鳴き声を持っている
      - 犬 → ワン
      - 猫 → にゃー
    - ポリモーフィズムを利用しない場合
      - それぞれのクラスを直接呼び出し、鳴き声を取得することになる
        - 犬.鳴き声
        - 猫.鳴き声
    - ポリモーフィズムを利用すると
      - 動物の鳴き声を返すメソッドを作る
        - どの動物?かの部分だけ設定してあげればこの鳴き声が返ってくるよねという実装がされている
      - 鳴き声(犬) → ワン
      - 鳴き声(猫) → にゃー







やったことを記録する
比較する際に表にまとめて整理する
質問する為の下調べ

調べることで自分の知識を深め、相手に教えることが出来るようになる為
ある程度調べておくことで聞く際も言いたいこと、聞きたいことが伝わりやすくなるはず

自分の場合、これが必要だと思って調べておいたのに
聞く際に必要でないと思ってしまっている
