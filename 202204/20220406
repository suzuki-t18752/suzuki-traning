### aws DBの削除
1. 削除対象のデータベースを選択
- 親子がある場合、子のデータベースを選択する
  - 子が全て削除されると自動で親も削除される

2. アクション内の停止を選択する

3. リロードボタンを押下して停止中になっていることを確認

4. 少し待ち、停止中だったDBが停止済になっていることを確認

5. アクション内の削除を押下する

6. 画面上からDBがなくなる



### [mysql GROUP_CONCAT](https://dev.mysql.com/doc/refman/8.0/ja/aggregate-functions.html#function_group-concat)
- GROUP BYした際に使う
- 複数ある列を1つのカラムにまとめることが出来る
```
mysql> SELECT t_id, GROUP_CONCAT(p_id) FROM t_p GROUP BY t_id limit 10;
+-------------+----------------------------------------------------------------------------------------+
| t_id        | GROUP_CONCAT(p_id)                                                                     |
+-------------+----------------------------------------------------------------------------------------+
|           1 | 8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36   |
|           2 | 7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36 |
|           3 | 7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36 |
|           4 | 7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36 |
|           5 | 7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36 |
|           6 | 7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36 |
|           7 | 7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36 |
|           8 | 7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36 |
|           9 | 7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36 |
|          10 | 7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36 |
+-------------+----------------------------------------------------------------------------------------+
10 rows in set (0.00 sec)
```


- 結果は、group_concat_max_len システム変数で指定された最大長まで切り捨てられます。その変数のデフォルト値は 1024 です。 さらに高い値にも設定できますが、戻り値の有効な最大長は、max_allowed_packet の値によって制約されます。 実行時に group_concat_max_len の値を変更するための構文は、次のとおりです。ここで、val は符号なし整数です。
- 戻り値は、引数が非バイナリとバイナリのどちらの文字列であるのかに応じて、非バイナリ文字列またはバイナリ文字列になります。 結果の型は、group_concat_max_len が 512 以下の場合 (この場合、結果の型は VARCHAR または VARBINARY です) を除いて、TEXT または BLOB です。
```
mysql> SHOW VARIABLES LIKE 'group_concat_max_len';
+----------------------+-------+
| Variable_name        | Value |
+----------------------+-------+
| group_concat_max_len | 1024  |
+----------------------+-------+
1 row in set (0.00 sec)
```


### ピア
- https://e-words.jp/w/%E3%83%94%E3%82%A2.html#:~:text=%E3%83%94%E3%82%A2%E3%81%A8%E3%81%AF%E3%80%81%E5%90%8C%E5%83%9A%E3%80%81%E5%90%8C%E8%BC%A9,%E3%81%AE%E3%81%93%E3%81%A8%E3%82%92%E3%83%94%E3%82%A2%E3%81%A8%E3%81%84%E3%81%86%E3%80%82
- https://wa3.i-3-i.info/word1306.html
- サーバーとクライアントのような役割分担や上下関係のない、対等な機器同士が相互に通信する接続形態


### トラフィック
- https://wa3.i-3-i.info/word1972.html
- ネットワークに流れる情報もしくは情報量のこと



## ruby 速度向上について
- https://zenn.dev/universato/articles/20201210-z-ruby
### HashはStringよりもSymbolの方が早い
```
hash = []
10000.times do; hash << {'test' => 1, 'test2' => 2, 'test3' => 3}; end
Benchmark.realtime do; hash.map{|t| p t['test']; p t['test2']; p t['test3']}; end
=> 0.5202363999560475
Benchmark.realtime do; hash.map(&:symbolize_keys).map {|t| p t[:test]; p t[:test2]; p t[:test3]}; end
=> 0.539968500030227

100000.times do; hash << {'test' => 1, 'test2' => 2, 'test3' => 3}; end
Benchmark.realtime do; hash.map{|t| p t['test']; p t['test2']; p t['test3']}; end
=> 5.148713000002317
=> 3.9413106000283733
=> 4.42517649999354
=> 4.173284500022419
=> 3.981059300014749
Benchmark.realtime do; hash.map(&:symbolize_keys).map {|t| p t[:test]; p t[:test2]; p t[:test3]}; end
=> 4.419451100053266
=> 4.417661200044677
=> 4.711293799919076
=> 4.091005999944173
=> 4.3286230999510735

100000.times do; hash << {test: 1, test2: 2, test3: 3}; end
Benchmark.realtime do; hash.map {|t| p t[:test]; p t[:test2]; p t[:test3]}; end
=> 5.0257558999583125
=> 4.2126769999740645
=> 3.8549622000427917
=> 4.151256800047122
=> 3.9991251999745145
```
- 文字列が長い方が効果が高い
```
100000.times do; hash << {'test123456789' => 1, 'testtest123456789' => 2, 'testtesttest123456789' => 3}; end
Benchmark.realtime do; hash.map{|t| p t['test123456789']; p t['testtest123456789']; p t['testtesttest123456789']}; end
=> 5.308806000044569
=> 4.065432600094937
=> 4.814307799912058
=> 4.498210899997503
Benchmark.realtime do; hash.map(&:symbolize_keys).map{|t| p t[:test123456789]; p t[:testtest123456789]; p t[:testtesttest123456789]}; end
=> 5.446384100010619
=> 3.935182800050825
=> 3.8973109000362456
=> 3.9013007000321522

100000.times do; hash << {test123456789: 1, testtest123456789: 2, testtesttest123456789: 3}; end
Benchmark.realtime do; hash.map{|t| p t[:test123456789]; p t[:testtest123456789]; p t[:testtesttest123456789]}; end
=> 4.644412699970417
=> 3.51008959999308
=> 3.764685000060126
=> 3.6622434000018984
```

### Stringの結合
- 基本的には << を使うのが一番早い
  - ただ破壊的変更にあたる為、rails等では制限がかかるので注意
- あとStringクラスの変数を結合する場合は式展開("#{}")を使う方がよい
  - 速度的には遅くなるが式展開を使うと自動的にto_sメソッドが実行され、nil等の場合でも対応できるよう
    - そもそも先にnilは除外するべきだが
```
[3] pry(main)> a = 'test'
=> "test"
[4] pry(main)> b = ''
=> ""
[5] pry(main)> Benchmark.realtime do

    b += a
[5] pry(main)> Benchmark.realtime do
[5] pry(main)*   100000.times do
[5] pry(main)*     b += a
[5] pry(main)*   end
[5] pry(main)* end
=> 15.999634900013916
[6] pry(main)> a = 'test'
=> "test"
[7] pry(main)> b = ''
=> ""
[8] pry(main)> Benchmark.realtime do
[8] pry(main)*   100000.times do   do
[8] pry(main)*     b = "#{b}#{a}"
[8] pry(main)*   end
[8] pry(main)* end
=> 13.800291599938646
[16] pry(main)> Benchmark.realtime do
[16] pry(main)*   100000.times do
[16] pry(main)*     b << a
[16] pry(main)*   end
[16] pry(main)* end
=> 0.011096699978224933
```
